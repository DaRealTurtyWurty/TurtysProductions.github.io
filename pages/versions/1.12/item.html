<!DOCTYPE html>
<html lang="en">
    <head>
        <title>1.12.2 Item.java</title>
        <link rel="stylesheet" href="../../../dictionaryStyle.css">
    </head>
    <body>
        <nav>
            <ul>
                <li class="active"><a href="../../moddingdictionary.html" class="aactive">Modding Version Dictionaries</a></li>
                <li class="active"><a href="../../minecraftmods.html" class="inactive">My Minecraft Mods</a></li>
                <li class="active"><a href="../../../index.html" class="inactive">Home</a></li>
            </ul>
            <h1>Turty's Productions</h1>
        </nav>
        <section>
                <p class="headingPara">Item.java methods and variables</p>
                <h6>
                    <ul>
                        <br><h6><strong>addInformation</strong> is a <strong>public void</strong> so it does not return anything, 
                            it is used for adding a tooltip to the item(a short description). 
                            <strong>stack</strong> is the itemstack to add the tooltip to. 
                            <strong>worldIn</strong> is the world that the stack is in. 
                            <strong>tooltip</strong> allows you to then add a tooltip 
                            using <strong>tooltip.add()</strong>. Finally 
                            <strong>flagIn</strong> can be used to declare 
                            whether it is an <code><strong>ADVANCED</strong></code> 
                            tooltip or a <strong><code>NORMAL</strong></code> tooltip.</h6>
                        <li class="items"><code>addInformation(ItemStackStack stack, World worldIn, List&lt;String&gt; tooltip, ITooltipFlag flagIn)</code></li>
                        <hr>
                        <br><br><h6><strong>canApplyAtEnchantingTable</strong> 
                            is a <strong>public boolean</strong> so it returns 
                            <strong>true</strong> or <strong>false</strong>, 
                            it returns true if the enchantment can be applied to this item. <strong>stack </strong>
                            is the itemstack to be enchanted. <strong>enchantment</strong> is the enchantment to be 
                            applied. This method checks whether an item can be enchanted with a certain 
                            enchantment. This applies specifically to enchanting an item in the 
                            enchanting table and is called when retrieving the list of possible 
                            enchantments for an item.</h6>
                        <li class="items"><code>canApplyAtEnchantingTable(ItemStack stack, Enchantment enchantment)</code></li>
                        <hr>
                        <br><br><h6><strong>canDestroyBlockInCreative</strong> 
                            is a <strong>public boolean</strong> so it returns 
                            <strong>true</strong> or <strong>false</strong>, 
                            it returns true if the given player can destroy 
                            the specified block in creative mode with this item. 
                            <strong>world</strong> is the world that the block is in. 
                            <strong>pos</strong> is the position of the block in the world. 
                            <strong>stack</strong> is the itemstack that can/cannot break the block. 
                            <strong>player</strong> is the player that is trying to break the block.</h6>
                        <li class="items"><code>canDestroyBlockInCreative(World world, BlockPos pos, ItemStack stack, EntityPlayer player)</code></li>
                        <hr>
                        <br><br><h6><strong>canDisableShield</strong> 
                            is a <strong>public boolean</strong> so it returns 
                            <strong>true</strong> or <strong>false</strong>, 
                            it returns true if the item can disable a shield. 
                            <strong>stack</strong> is the itemstack. 
                            <strong>shield</strong> is the stack of the shield in question. 
                            <strong>entity</strong> is the EntityLivingBase that is holding the shield. 
                            <strong>attacker</strong> is the EntityLivingBase that is holding the itemstack.</h6>
                        <li class="items"><code>canDisableShield(ItemStack stack, ItemStack shield, EntityLivingBase entity, EntityLivingBase attacker)</code></li>
                        <hr>
                        <br><br><h6><strong>canHarvestBlock</strong> 
                            is a <strong>public boolean</strong> so it returns 
                            <strong>true</strong> or <strong>false</strong>, 
                            it returns true if the player can harvest a block with that itemstack. 
                            <strong>blockIn</strong> is the state of the block that is in question.</h6>
                        <li class="items"><code>canHarvestBlock(IBlockState blockIn)</code></li>
                        <hr>
                        <br><br><h6><strong>canHarvestBlock</strong> 
                            is a <strong>public boolean</strong> so it returns 
                            <strong>true</strong> or <strong>false</strong>, 
                            it returns true if the player can harvest a block with that itemstack. 
                            <strong>blockIn</strong> is the state of the block that is in question. 
                            <strong>stack</strong> is the itemstack. This is the ItemStack sensitive
                            version.
                        </h6>
                        <li class="items"><code>canHarvestBlock(IBlockState state, ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>canItemEditBlocks</strong> 
                            is a <strong>public boolean</strong> so it returns 
                            <strong>true</strong> or <strong>false</strong>, 
                            it returns true if this item ignores other restrictions 
                            on how a player can modify the world. 
                            Forces <strong>EntityPlayer#canPlayerEdit</strong> to return true.</h6>
                        <li class="items"><code>canItemEditBlocks()</code></li>
                        <hr>
                        <br><br><h6><strong>createEntity</strong> 
                            is a <strong>public Entity</strong>, so should return a new entity 
                            to replace the dropped item. Returning <strong>null </strong>
                            here will not kill the <strong>EntityItem</strong> and will leave 
                            it to function normally. Called when the item 
                            is placed in a world. <strong>world</strong> is the world object. 
                            <strong>location</strong> is the <strong>EntityItem</strong> object, and is useful 
                            for getting the position of the entity. 
                            <strong>itemStack</strong> is the current itemstack.</h6>
                        <li class="items"><code>createEntity(World world, Entity location, ItemStack itemstack)</code></li>
                        <hr>
                        <br><br><h6><strong>doesSneakBypassUse</strong> 
                            is a <strong>public boolean</strong> so it returns 
                            <strong>true</strong> or <strong>false</strong>, 
                            it returns true if this item, when held, allows 
                            sneak-clicks to pass through to the underlying block. 
                            <strong>stack</strong> is the current itemstack. 
                            <strong>world</strong> is the world. 
                            <strong>pos</strong> is the block position in the world. 
                            <strong>player</strong> is the player that is wielding the item.</h6>
                        <li class="items"><code>doesSneakBypassUse(ItemStack stack, IBlockAccess world, BlockPos pos, EntityPlayer player)</code></li>
                        <hr>
                        <br><br><h6><strong>getAnimationParameters</strong> 
                            is a bit complex and is a <strong>public ImmutableMap&lt;String, ITimeValue&gt;</strong>. 
                            All 3 parameters are <strong>final</strong> as <strong>ImmutableMap</strong>s can only have 
                            contents that will never change. 
                            <strong>stack</strong> is the current itemstack. 
                            <strong>world</strong> is the world object. 
                            <strong>entity</strong> is the <strong>EntityLivingBase</strong> that this animation is affecting. 
                            It is used to retrieve parameters to an item animation 
                            mechanism which is known as animation state machine or 
                            ASM(not to be confused with the Advanced System Manager). 
                            You can read about this in the Forge Docs 
                            <a href="https://mcforge.readthedocs.io/en/latest/animation/intro/" class="hyperlink"><strong>here</strong></a> as it does 
                            get very complex! It is mostly unused in forge, so it is 
                            unlikely for the common user to ever need it, but it 
                            is there just in case.</h6>
                        <li class="items"><code>getAnimationParameters(ItemStack stack, World world, EntityLivingBase entity)</code></li>
                        <hr>
                        <br><br><h6><strong>getArmorModel</strong> 
                            is a <strong>public String</strong>, and is called by <strong>RenderBiped</strong> and 
                            <strong>RenderPlayer</strong> to determine the armor texture that 
                            should be use for the currently equipped item. 
                            This will only be called on instances of <strong>ItemArmor</strong>. 
                            It returns the path of texture to bind, or return 
                            <strong>null</strong> to use the default path. 
                            <strong>stack</strong> is the itemstack for the equipped armor. 
                            <strong>entity</strong> is the entity that is wearing the armor. 
                            <strong>slot</strong> is the <strong>EntityEquipmentSlot</strong> that the armor is in. 
                            <strong>type</strong> is the subtype; can be <strong>null</strong> or <strong>"overlay"</strong>.</h6>
                        <li class="items"><code>getArmorModel(EntityLivingBase entityLiving, ItemStack itemStack, EntityEquipmentSlot armorSlot, ModelBiped _default)</code></li>
                        <hr>
                        <br><br><h6><strong>getContainerItem</strong> 
                            is a <strong>public Item</strong> and gets 
                            the item that is a container item, this means 
                            that it has a crafting result for example. 
                            This is the non-itemstack sensitive version. 
                            This method is nullable which means that 
                            it can return <strong>null</strong>, but 
                            otherwise it returns the resulting Item.</h6>
                        <li class="items"><code>getContainerItem()</code></li>
                        <hr>
                        <br><br><h6><strong>getContainerItem</strong> 
                            is the itemstack sensitive version 
                            of <strong> getContainerItem()</strong> and is a <strong>public ItemStack</strong>, 
                            this means that it returns the resulting itemstack. 
                            <strong>itemStack</strong> is the current itemstack.</h6>
                        <li class="items"><code>getContainerItem(ItemStack itemStack)</code></li>
                        <hr>
                        <br><br><h6><strong>getCreativeTab</strong> 
                            is a <strong>public CreativeTabs</strong> and 
                            gets the <strong>CreativeTabs</strong> that 
                            this item is displayed on. It returns the tab 
                            for it to be displayed on.</h6>
                        <li class="items"><code>getCreativeTab()</code></li>
                        <hr>
                        <br><br><h6><strong>getCreativeTabs</strong> 
                            is a <strong>public CreativeTabs[]</strong>, so it 
                            returns a list of all tabs that this item could 
                            possibly be on. The method gets a list of tabs 
                            that items belonging to this class can display on, 
                            combined properly with <strong>getSubItems()</strong> allows for a 
                            single item to span many sub-items across many tabs.</h6>
                        <li class="items"><code>getCreativeTabs()</code></li>
                        <hr>
                        <br><br><h6><strong>getCreatorModId</strong> 
                            is a <strong>public String</strong>, so it returns the Mod ID 
                            for the itemstack, or null when there is no specially associated 
                            mod and <strong>getRegistryName()</strong> would 
                            return <strong>null</strong>. It is called to 
                            get the Mod ID of the mod that *created* the itemstack, 
                            instead of the real Mod ID that *registered* it. 
                            For example the Forge Universal Bucket creates a 
                            sub-item for each modded fluid, and it returns 
                            the modded fluid's Mod ID here. Mods that register 
                            sub-items for other mods can override this. 
                            Informational mods can call it to show the 
                            mod that created the item. 
                            <strong>itemStack</strong> is the itemstack to check.</h6>
                        <li class="items"><code>getCreatorModId(ItemStack itemStack)</code></li>
                        <hr>
                        <br><br><h6><strong>getDamage</strong> 
                            is a <strong>public int</strong> and returns 
                            the <strong>itemDamage</strong> represented by this 
                            ItemStack(the damage value), the 'damage' 
                            is more commonly known as durability. 
                            This defaults to the <strong>itemDamage</strong> field on <strong>ItemStack</strong>, 
                            but can be overridden here for other sources 
                            such as NBT. <strong>stack</strong> is the itemstack that is getting damaged.</h6>
                        <li class="items"><code>getDamage(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>getDefaultInstance</strong> 
                            is a <strong> public ItemStack</strong> and returns the 
                            itemstack to create a default instance of. For example 
                            this would affect if you wanted to do something 
                            like <strong>new ItemStack(Items.FLINT)</strong>.</h6>
                        <li class="items"><code>getDefaultInstance()</code></li>
                        <hr>
                        <br><br><h6><strong>getDestroySpeed</strong> 
                            is a <strong>public float</strong> and returns 
                            a <strong>float</strong> for the speed that this 
                            item destroys a block. 
                            <strong>stack</strong> is the current itemstack. 
                            <strong>state</strong> is the <strong>IBlockState</strong> of the 
                            block that you are breaking.</h6>
                        <li class="items"><code>getDestroySpeed(ItemStack stack, IBlockState state)</code></li>
                        <hr>
                        <br><br><h6><strong>getDurabilityForDisplay</strong> 
                            is a <strong>public double</strong> and returns the 
                            percentage of durability to display - 
                            <strong>0.0 for 100% (no damage / full bar), 1.0 for 0% (fully damaged / empty bar)</strong>. 
                            It queries the percentage of the 'Durability' bar that should be drawn. 
                            <strong>stack</strong> is the current itemstack.</h6>
                        <li class="items"><code>getDurabilityForDisplay(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>getEntityLifespan</strong> 
                            retrieves the normal 'lifespan' of this item when it 
                            is dropped on the ground as a <strong>EntityItem</strong>. 
                            This is in ticks, standard result is 6000, or 5 mins. 
                            It is a <strong>public int</strong> and returns the 
                            normal lifespan in ticks(<strong>20 ticks = 1 second</strong>). 
                            <strong>itemStack</strong> is the current itemstack. 
                            <strong>world</strong> is the world that the entity is in.</h6>
                        <li class="items"><code>getEntityLifespan(ItemStack itemStack, World world)</code></li>
                        <hr>
                        <br><br><h6><strong>getEquipmentSlot</strong> 
                            is a <strong>public EntityEquipmentSlot</strong> and 
                            returns the armor slot of the <strong>ItemStack</strong>, or <strong>null</strong> to 
                            let the default vanilla logic as per <strong>EntityLiving.getSlotForItemStack(stack)</strong> decide. 
                            Override this to set a non-default armor slot for an ItemStack, but 
                            do not use this to get the armor slot of said stack; for that, use 
                            <strong>net.minecraft.entity.EntityLiving.getSlotForItemStack(ItemStack)</strong>. 
                            <strong>stack</strong> is the item stack.</h6>
                        <li class="items"><code>getEquipmentSlot(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>getFontRenderer</strong> 
                            is a <strong>public FontRenderer</strong> and returns 
                            the font renderer used to render tooltips and overlays 
                            for this item. Returning <strong>null</strong> will use the 
                            standard font renderer. 
                            <strong>stack</strong> The current item stack.</h6>
                        <li class="items"><code>getFontRenderer(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>getHarvestLevel</strong> 
                            is a <strong>public int</strong> and returns the 
                            harvest level, or -1 if not the specified tool type. 
                            It queries the harvest level of this item stack for the specified tool class. 
                            <strong>stack</strong> is this itemstack instance. 
                            <strong>toolClass</strong> is the string class name for a tool.</h6>
                        <li class="items"><code>getHarvestLevel(ItemStack stack, String toolClass, EntityPlayer player, IBlockState blockState)</code></li>
                        <hr>
                        <br><br><h6><strong>getHasSubtypes</strong> 
                            is a <strong>public boolean</strong> and returns <strong>true</strong>
                            if the item has metadata such as dye having 16 variants. 
                            This should not be used as it is totally removed in version 1.13+, however 
                            it will still work. It is known as bad practice to utilize it though.</h6>
                        <li class="items"><code>getHasSubtypes()</code></li>
                        <hr>
                        <br><br><h6><strong>getHighlightTip</strong> 
                            is a <strong>public String</strong> and allows the item one 
                            last chance to modify its name used for the tool highlight 
                            useful for adding something extra that can't be removed by a 
                            user in the displayed name, such as a mode of operation. 
                            <strong>item</strong> is the item stack for the item. 
                            <strong>displayName</strong> is the name that will be displayed 
                            unless it is changed in this method.</h6>
                        <li class="items"><code>getHighlightTip(ItemStack item, String displayName)</code></li>
                        <hr>
                        <br><br><h6><strong>getHorseArmorTexture</strong> 
                            is a <strong>public String</strong> and therefore returns 
                            the name of the texture which is is wanted on the armor. 
                            It allows you to change the texture on the horse. 
                            <strong>wearer</strong> is the <strong>EntityLiving</strong> that has the armor equipped. 
                            <strong>stack</strong> is the current ItemStack.</h6>
                        <li class="items"><code>getHorseArmorTexture(EntityLiving wearer, ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>getHorseArmorType</strong> 
                            is a <strong>public HorseArmorType</strong> and therefore returns 
                            an enum constant of type <strong>HorseArmorType</strong>. 
                            You return <strong>HorseArmorType.NONE</strong> if this item is 
                            not horse armor. The returned enum constant will be used to 
                            determine the armor value and texture of this item when equipped. 
                            <strong>stack</strong> is the armor stack.</h6>
                        <li class="items"><code>getHorseArmorType(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>getIsRepairable</strong> 
                            is a <strong>public boolean</strong> and returns <strong>true</strong> 
                            if this itemstack is repairable in an anvil. 
                            <strong>toRepair</strong> is the itemstack that is being repaired. 
                            <strong>repair</strong> is the itemstack being used to 
                            perform the repair(such as iron ingot for iron armor).</h6>
                        <li class="items"><code>getIsRepairable(ItemStack toRepair, ItemStack repair)</code></li>
                        <hr>
                        <br><br><h6><strong>getItemAttributeModifiers</strong> 
                            is a <strong>public Multimap&lt;String, AttributeModifier&gt;</strong> and 
                            gets a map of item attribute modifiers, used by <strong>ItemSword</strong> to 
                            increase hit damage. <strong>equipmentSlot</strong> is the <strong>EntityEquipmentSlot</strong> that 
                            the ItemStack is in. This method is deprecated and instead you should use the 
                            ItemStack sensitive version <strong>getItemAttributeModifiers(EntityEquipmentSlot equipmentSlot, ItemStack stack)</strong>.</h6>
                        <li class="items"><code>getItemAttributeModifiers(EntityEquipmentSlot equipmentSlot)</code></li>
                        <hr>
                        <br><br><h6><strong>getItemBurnTime</strong> 
                            is a <strong>public int</strong> and returns the fuel 
                            burn time for this itemStack in a furnace. Return <strong>0</strong> to 
                            make it not act as a fuel. Return <strong>-1</strong> to let the 
                            default vanilla logic decide. 
                            <strong>itemStack</strong> is the item stack which is being queried about.</h6>
                        <li class="items"><code>getItemBurnTime(ItemStack itemStack)</code></li>
                        <hr>
                        <br><br><h6><strong>getItemEnchantability</strong> 
                            is a <strong>public int</strong> and returns the 
                            <strong>enchantability factor</strong> of the item, most of 
                            the time is based on material. </h6>
                        <li class="items"><code>getItemEnchantability()</code></li>
                        <hr>
                        <br><br><h6><strong>getItemEnchantability</strong> 
                            is a <strong>public int</strong> and is the itemstack 
                            sensitive version of <strong>getItemEnchantability()</strong>. 
                            It returns the item enchantability value of the ItemStack. 
                            <strong>stack</strong> is the current ItemStack.</h6>
                        <li class="items"><code>getItemEnchantability(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>getItemStackDisplayName</strong> 
                            is a <strong>public String</strong> and returns the 
                            display name for this ItemStack. 
                            <strong>stack</strong> is the itemstack to have it's name changed.</h6>
                        <li class="items"><code>getItemStackDisplayName(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>getItemStackLimit</strong> 
                            is the maximum number of items that the ItemStack can hold. 
                            It is a <strong>public int</strong> and therefore returns 
                            an integer value of the max number of items in the stack. 
                            This method is deprecated and you should use the ItemStack sensitive version. 
                            Even though it is named <strong>get</strong>, it is actually 
                            a <strong>set</strong> method.</h6>
                        <li class="items"><code>getItemStackLimit()</code></li>
                        <hr>
                        <br><br><h6><strong>getItemUseAction</strong> 
                            is a <strong>public EnumAction</strong> and returns the action 
                            that specifies what animation to play when the items is being used. 
                            <strong>stack</strong> is the item stack to apply the action to.</h6>
                        <li class="items"><code>getItemUseAction(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>getMaxDamage</strong> 
                            is a <strong>public int</strong> and returns the 
                            maximum damage(more commonly known as durability) that the item 
                            can take as an integer. This method is deprecated and 
                            you should use the ItemStack sensitive version. </h6>
                        <li class="items"><code>getMaxDamage()</code></li>
                        <hr>
                        <br><br><h6><strong>getMaxDamage</strong> 
                            is a <strong>public int</strong> and returns 
                            the <strong>maxDamage</strong>(maxDurability) for this ItemStack. 
                            Defaults to the maxDamage field in this item, but can be overridden 
                            here for other sources such as NBT.  
                            <strong>stack</strong> is the item stack that can be damaged.</h6>
                        <li class="items"><code>getMaxDamage(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>getMaxItemUseDuration</strong> 
                            is used for getting the max number of times the item can be 
                            used before consumed.  It is a <strong>public int</strong> and 
                            therefore requires an integer to be returned. 
                            <strong>stack</strong> is the itemstack to be used.</h6>
                        <li class="items"><code>getMaxItemUseDuration(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>getMetadata</strong> 
                            converts the given ItemStack damage value into a metadata 
                            value to be placed in the world when this Item is placed as 
                            a Block (mostly used with <strong>ItemBlocks</strong>). 
                            It is a <strong>public int</strong> as it returns an integer 
                            value. <strong>damage</strong> is an integer value for the 
                            current damage of the item.</h6>
                        <li class="items"><code>getMetadata(int damage)</code></li>
                        <hr>
                        <br><br><h6><strong>getMetadata</strong> 
                            used to be 'display damage', but its really just 'aux' data 
                            in the ItemStack, usually shares the same variable as damage. 
                            <strong>stack</strong> is the ItemStack to get the metadata from. 
                            It is a <strong>public int</strong> as it returns an integer 
                            value of the damage.</h6>
                        <li class="items"><code>getMetadata(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>getNBTShareTag</strong> 
                            can be overridden to change the NBT data being sent to the client. 
                            You should <strong>ONLY</strong> override this when you have no other choice, 
                            as this might change behavior client side! Note that this will sometimes be 
                            applied multiple times, the following MUST be supported: 
                            <strong>Item item = stack.getItem();</strong> 
                            <strong>NBTTagCompound nbtShare1 = item.getNBTShareTag(stack);</strong> 
                            <strong>stack.setTagCompound(nbtShare1);</strong> 
                            <strong>NBTTagCompound nbtShare2 = item.getNBTShareTag(stack);</strong> assert 
                            <strong>nbtShare1.equals(nbtShare2);</strong>. 
                            It is a <strong>public NBTTagCompound</strong> as it returns the NBT tag. 
                            <strong>stack</strong> is the stack to send the NBT tag for.</h6>
                        <li class="items"><code>getNBTShareTag(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6>Firstly, an <strong>IItemPropertyGetter</strong> is just a function 
                            that extracts a property from an itemstack(sort of like a lens). 
                            This method just retrieves one of these 'lenses' by a <strong>ResourceLocation</strong> identifier. 
                            This gets called to apply a property after the 'state' of the item has changed. 
                            Some examples of this are the clock and bow where they both have different 'states', 
                            so it set different icons depending on an external factor.  
                            <strong>key</strong> is the resource location and is the identifier. 
                            It is a <strong>public IItemPropertyGetter</strong> and must return a 
                            new instance of <strong>IItemPropertyGetter</strong> and have the 
                            <strong>apply</strong> method inside.</h6>
                        <li class="items"><code>getPropertyGetter(ResourceLocation key)</code></li>
                        <hr>
                        <br><br><h6><strong>getRarity</strong> 
                            is a <strong>public EnumRarity</strong> and gets an item rarity 
                            from <strong>EnumRarity</strong>, these rarities change the text 
                            color to suit how rare the item is, such as an Enchanted Golden Apple. 
                            <strong>stack</strong> is the item stack to get the rarity of.</h6>
                        <li class="items"><code>getRarity(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>getRGBDurabilityForDisplay</strong> 
                            is a <strong>public int</strong> and returns a packed RGB value for 
                            the durability color (0x00RRGGBB). This is used to render the durability 
                            bar in the GUI. This defaults to a value based on the hue 
                            scaled based on <strong>getDurabilityForDisplay</strong>, but can be overridden. 
                            <strong>stack</strong> is the item stack to get the RGB durability display from.</h6>
                        <li class="items"><code>getRGBDurabilityForDisplay(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>getSmeltingExperience</strong> 
                            determines the base experience for a player when they remove this 
                            item from a furnace slot. This number must be between 0 and 1 for 
                            it to be valid as it is <strong>public float</strong>. 
                            This number will be multiplied by the stack size to get the total experience. 
                            <strong>item</strong> is the item stack that the player is picking up.</h6>
                        <li class="items"><code>getSmeltingExperience(ItemStack item)</code></li>
                        <hr>
                        <br><br><h6><strong>getShareTag</strong> 
                            is a <strong>public boolean</strong> and if this function 
                            returns <strong>true</strong> (or the item is damageable), the 
                            ItemStack's NBT tag will be sent to the client.</h6>
                        <li class="items"><code>getShareTag()</code></li>
                        <hr>
                        <br><br><h6><strong>getSubItems</strong> 
                            is a <strong>public void</strong> and therefore you cannot 
                            return anything. However, it returns a list of items with the same ID, but 
                            different meta (e.g. dye returns 16 items). <strong>tab</strong> is the Creative Tab 
                            for these sub-items to be in. <strong>items</strong> is a list of non null 
                            item stacks of the sub-items. This should not be used as it is totally 
                            removed in version 1.13+, however it will still work. 
                            It is known as bad practice to utilize it though.</h6>
                        <li class="items"><code>getSubItems(CreativeTabs tab, NonNullList<ItemStack> items)</code></li>
                        <hr>
                        <br><br><h6><strong>getToolClasses</strong> 
                            is a <strong>public Set&lt;String&gt;</strong> and returns a list of 
                            string versions of tool classes such as <strong>"pickaxe"</strong>. 
                            <strong>stack</strong> is the item stack to get the tool classes from.</h6>
                        <li class="items"><code>getToolClasses(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>getUnlocalizedName</strong> 
                            is a <strong>public String</strong> and returns the unlocalized name 
                            of this item for it to then be localized in the lang file.</h6>
                        <li class="items"><code>getUnlocalizedName()</code></li>
                        <hr>
                        <br><br><h6><strong>getUnlocalizedName</strong> 
                            is a <strong>public String</strong> and returns the unlocalized name 
                            of this item for it to then be localized in the lang file. This version accepts an 
                            <strong>ItemStack</strong> so different stacks can have different names based on their damage or NBT. 
                            <strong>stack</strong> is the item stack to get the unlocalized name of.</h6>
                        <li class="items"><code>getUnlocalizedName(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>getUnlocalizedNameInefficiently</strong> 
                            is a <strong>public String</strong> and translates the unlocalized name 
                            of this item, but without the <strong>.name</strong> suffix, so the translation 
                            fails and the unlocalized name itself is returned. 
                            <strong>stack</strong> is the item stack to get the unlocalized name of.</h6>
                        <li class="items"><code>getUnlocalizedNameInefficiently(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>hasContainerItem</strong> 
                            is a <strong>public boolean</strong> and should return <strong>true</strong> 
                            if this <strong>Item</strong> has a container item (a.k.a. crafting result). 
                            An example of this is the cake recipe where it gives you back the bucket from the bucket of milk. 
                            This method is deprecated, so you should use the ItemStack sensitive version.</h6>
                        <li class="items"><code>hasContainerItem()</code></li>
                        <hr>
                        <br><br><h6><strong>hasContainerItem</strong> 
                            is the ItemStack sensitive version of <strong>hasContainerItem()</strong> and 
                            returns <strong>true</strong> if this item has a 'container'. 
                            <strong>stack</strong> is the current item stack.</h6>
                        <li class="items"><code>hasContainerItem(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>hasCustomEntity</strong> 
                            determines if this Item has a special entity for when they are in the world. 
                            This is called when an <strong>EntityItem</strong> is spawned in the world, 
                            if <strong>true</strong> and <strong>Item#createCustomEntity</strong> returns non-null, 
                            the <strong>EntityItem</strong> will be destroyed and the new 
                            Entity will be added to the world. <strong>stack</strong> is the 
                            current item stack. This is a <strong>public boolean</strong>, and therefore 
                            must return either <strong>true</strong> or <strong>false</strong>.</h6>
                        <li class="items"><code>hasCustomEntity(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>hasCustomProperties</strong> 
                            is a <strong>public boolean</strong>, and therefore must return 
                            either <strong>true</strong> or <strong>false</strong>. 
                            This will return <strong>true</strong> if this item has 
                            an <strong>IItemPropertyGetter</strong> and therefore has different 'states'.</h6>
                        <li class="items"><code>hasCustomProperties()</code></li>
                        <hr>
                        <br><br><h6><strong>hasEffect</strong> 
                            is a <strong>public boolean</strong>, and therefore must return 
                            either <strong>true</strong> or <strong>false</strong>. 
                            It returns <strong>true</strong> if this item has an enchantment glint. 
                            By default, this returns <strong>stack.isItemEnchanted()</strong>, but other 
                            items can override it (for instance, written books always return true). 
                            Note that if you override this method, you generally want to also call the 
                            super version (on Item) to get the glint for enchanted items. 
                            Of course, that is unnecessary if the overwritten version always returns true. 
                            <strong>stack</strong> is the item stack to apply the enchantment glint to.</h6>
                        <li class="items"><code>hasEffect(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>hitEntity</strong> 
                            - Current implementations of this method in child classes do not use 
                            the entry argument beside <strong>ev</strong>. They just raise the damage on the stack. 
                            This is a <strong>public boolean</strong>, so it must return 
                            either <strong>true</strong> or <strong>false</strong>. 
                            If it returns <strong>true</strong>, the event will continue and the entity will be hit. 
                            However if it returns <strong>false</strong> then the event will be cancelled and the entity will not be hit. 
                            <strong>stack</strong> is the current item stack that is hitting the entity. 
                            <strong>target</strong> is the <strong>EntityLivingBase</strong> that is hitting the entity. 
                            <strong>attacker</strong> is the <strong>EntityLivingBase</strong> that is attacking the entity.</h6>
                        <li class="items"><code>hitEntity(ItemStack stack, EntityLivingBase target, EntityLivingBase attacker)</code></li>
                        <hr>
                        <br><br><h6><strong>initCapabilities</strong> 
                            is called from <strong>ItemStack.setItem</strong>, and will hold extra 
                            data for the life of this ItemStack. This can be retrieved from <strong>stack.getCapabilities()</strong>. 
                            The NBT can be <strong>null</strong> if this is not called from <strong>readNBT</strong> or 
                            if the item stack that it is changing <strong><code>FROM</code></strong> is different 
                            than this item, or the previous item had no capabilities. This is called <code><strong>BEFORE</code></strong> the 
                            stacks item is set so you can use <strong>stack.getItem()</strong> to see 
                            the <code><strong>OLD</code></strong> item. Remember that getItem <code><strong>CAN</code></strong> 
                            return <strong>null</strong>. This method has the identifiers: <strong>public ICapabilityProvider</strong> and 
                            returns a holder instance associated with this ItemStack where you can hold capabilities for
                            the life of this item. <strong>stack</strong> is the item stack. 
                            <strong>nbt</strong> is NBT of this item serialized, or <strong>null</strong>.</h6>
                        <li class="items"><code>initCapabilities(ItemStack stack, NBTTagCompound nbt)</code></li>
                        <hr>
                        <br><br><h6><strong>isBeaconPayment</strong> 
                            is a <strong>public boolean</strong> and returns <strong>true</strong> if 
                            this Item can be used as a payment to activate the vanilla beacon. 
                            <strong>stack</strong> is the item stack that is/isn't used as a payment.</h6>
                        <li class="items"><code>isBeaconPayment(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>isBookEnchantable</strong> 
                            is a <strong>public boolean</strong> and returns <strong>true</strong> 
                            if the enchantment is allowed. It's use its to allow or forbid the 
                            specific book/item combination as an anvil enchant. 
                            <strong>stack</strong> is the current item stack. 
                            <strong>book</strong> is an item stack of the book.</h6>
                        <li class="items"><code>isBookEnchantable(ItemStack stack, ItemStack book)</code></li>
                        <hr>
                        <br><br><h6><strong>isDamageable</strong> 
                            is a <strong>public boolean</strong> and returns <strong>true</strong> if 
                            the item can be damaged(has durability that can be lost). </h6>
                        <li class="items"><code>isDamageable()</code></li>
                        <hr>
                        <br><br><h6><strong>isDamaged</strong> 
                            is a <strong>public boolean</strong> and returns <strong>true</strong> if 
                            the item stack has already been damaged(lost durability). 
                            This is only called if <strong>isDamageable()</strong> is <strong>true</strong>. 
                            <strong>stack</strong> is the item stack that can is/is not damaged.</h6>
                        <li class="items"><code>isDamaged(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>isEnchantable</strong> 
                            is a <strong>public boolean</strong> and returns <strong>true</strong> if 
                            the item stack can be enchanted. It also checks <strong>isDamagable()</strong> and if 
                            it cannot be stacked. <strong>stack</strong> is the item stack that is/isn't enchantable. </h6>
                        <li class="items"><code>isEnchantable(ItemStack stack)</code></li>
                        <hr>
                        <br><br><h6><strong>isFull3D</strong> 
                            is a <strong>public boolean</strong> and returns <strong>true</strong> if 
                            the item is rendered in full 3D when held.</h6>
                        <li class="items"><code>isFull3D()</code></li>
                        <hr>
                        <br><br><h6><strong>isInCreativeTab</strong> 
                            is a <strong>protected boolean</strong> and returns <strong>true</strong> if 
                            the item is in a creative tab. <strong>targetTab</strong> is the 
                            creative tab in question as it loops through all the creative tabs 
                            and checks if it is in one.</h6>
                        <li class="items"><code>isInCreativeTab(CreativeTabs targetTab)</code></li>
                        <hr>
                        <br><br><h6><strong>isMap</strong> 
                            is a <strong>public boolean</strong> and returns <strong>false</strong> 
                            unless the item is a sub-class of <strong>ItemMapBase</strong>. 
                            This just tells the client that the player is holding a map.</h6>
                        <li class="items"><code>isMap()</code></li>
                        <hr>
                        <br><br><h6><strong>isRepairable</strong> 
                            is a <strong>public boolean</strong> and 
                            returns <strong>true</strong> if the item is repairable. 
                            This is called by <strong>CraftingManager</strong> to 
                            determine if an item is reparable.</h6>
                        <li class="items"><code>isRepairable()</code></li>
                        <hr>
                        <br><br><h6><strong>isShield</strong> 
                            is a <strong>public boolean</strong> and returns <strong>true</strong> if 
                            this item is considered a shield. 
                            <strong>stack</strong> is the item stack that is/isn't a shield. 
                            <strong>entity</strong> is the <strong>EntityLivingBase</strong> that is holding the stack.</h6>
                        <li class="items"><code>isShield(ItemStack stack, EntityLivingBase entity)</code></li>
                        <hr>
                        <br><br><h6><strong>isValidArmor</strong> 
                            is a <strong>public boolean</strong> and 
                            returns <strong>true</strong> if the given <strong>ItemStack</strong> can 
                            be inserted in an armor slot. This determines if the specific ItemStack 
                            can be placed in the specified armor slot, for the entity. 
                            <strong>stack</strong> is the item stack. 
                            <strong>armorType</strong> is the armor slot to be verified. 
                            <strong>entity</strong> is the entity trying to equip the armor. 
                            Note that in 1.13 this changes to <strong>canEquip()</strong>.</h6>
                        <li class="items"><code>isValidArmor(ItemStack stack, EntityEquipmentSlot armorType, Entity entity)</code></li>
                        <hr>
                        <br><br><h6><strong>itemInteractionForEntity</strong> 
                            is a <strong>public boolean</strong> and 
                            returns <strong>true</strong> if the item can be used on the 
                            given entity, e.g. shears on sheep. <strong>stack</strong> is the 
                            item stack to check for interactions with entities. 
                            <strong>playerIn</strong> is the player that is trying to do the interaction. 
                            <strong>target</strong> is the entity that the interaction is trying to be done on. 
                            <strong>hand</strong> is the <strong>EnumHand</strong> that the stack is in.</h6>
                        <li class="items"><code>itemInteractionForEntity(ItemStack stack, EntityPlayer playerIn, EntityLivingBase target, EnumHand hand)</code></li>
                        <hr>
                    </ul>
                </h6>
            </section>
            <footer>
                Test
            </footer>
    </body>
</html>